
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Python Bindings &#8212; RePrimAnd 0.9997 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Little Helpers" href="little_helpers.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="python-bindings">
<span id="python-interface"></span><h1>Python Bindings<a class="headerlink" href="#python-bindings" title="Permalink to this heading">¶</a></h1>
<p>The <cite>RePrimAnd</cite> library also provides a Python3 extension module
<cite>pyreprimand</cite> that allows the use of the library from within
Python.</p>
<p>As an added benefit, functions from the C++ interface are vectorized
in the Python interface whenever it makes sense, meaning that it is
possible to evaluate those functions for <cite>numpy</cite>
arrays of arbitrary dimension. This should be very efficient since the
loops are performed in compiled C++ code.</p>
<section id="eos-objects">
<h2>EOS Objects<a class="headerlink" href="#eos-objects" title="Permalink to this heading">¶</a></h2>
<p>The Python bindings include the functionality of barotropic and thermal
EOS, as well as the functions to load and save these.
The Python bindings expose nearly all EOS methods, using the same naming
as the C++ interface. One difference is that the Python bindings do not
include the methods based on matter state objects, as this interface
is not suitable for work with arrays. Only the C++ methods for direct
evaluation of a single quantity, such as
<a class="reference internal" href="eos_thermal_ref.html#_CPPv4NK11EOS_Toolkit11eos_thermal19press_at_rho_eps_yeE6real_t6real_t6real_t" title="EOS_Toolkit::eos_thermal::press_at_rho_eps_ye"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">press_at_rho_eps_ye()</span></code></a>
are offered. As with the C++ pendants, they return NAN for invalid
input. Range-checking methods such as
<a class="reference internal" href="eos_thermal_ref.html#_CPPv4NK11EOS_Toolkit11eos_thermal12is_rho_validE6real_t" title="EOS_Toolkit::eos_thermal::is_rho_valid"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">is_rho_valid()</span></code></a> are also
exposed and can be used with numpy arrays, resulting in <cite>numpy</cite> arrays
of type <cite>bool</cite>. Another minor difference is that C++ getter methods
such as <a class="reference internal" href="eos_thermal_ref.html#_CPPv4NK11EOS_Toolkit11eos_thermal9range_rhoEv" title="EOS_Toolkit::eos_thermal::range_rho"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">range_rho()</span></code></a> are mapped to Python
object attributes, so in Python one should not add brackets ().</p>
<p>The example code below shows how to load a barotropic EOS and evaluate
the pressure for a numpy array of mass densities spanning the full EOS
valid range.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyreprimand</span> <span class="k">as</span> <span class="nn">pyr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">u</span>   <span class="o">=</span> <span class="n">pyr</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">geom_solar</span><span class="p">()</span>
<span class="n">eos</span> <span class="o">=</span> <span class="n">pyr</span><span class="o">.</span><span class="n">load_eos_barotr</span><span class="p">(</span><span class="s2">&quot;EOS/MS1_PP.eos.h5&quot;</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>

<span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">eos</span><span class="o">.</span><span class="n">range_rho</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">eos</span><span class="o">.</span><span class="n">range_rho</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">press</span> <span class="o">=</span> <span class="n">eos</span><span class="o">.</span><span class="n">press_at_rho</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="creating-eos-files">
<h2>Creating EOS Files<a class="headerlink" href="#creating-eos-files" title="Permalink to this heading">¶</a></h2>
<p>One prime use for the Python interface is the creation of EOS files based on
data from other sources. Polytropic, piecewise polytropic, and spline-based
EOS for tabulated data are supported directly. Other EOS types can be represented
by first sampling them.</p>
<p>Creating a piecewise polytropic EOS file is as simple as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eos_units</span>   <span class="o">=</span> <span class="n">pyr</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">geom_solar</span><span class="p">()</span>

<span class="n">eos</span> <span class="o">=</span> <span class="n">pyr</span><span class="o">.</span><span class="n">make_eos_barotr_pwpoly</span><span class="p">(</span><span class="n">rho_poly</span><span class="p">,</span>
              <span class="n">rho_bounds</span><span class="p">,</span> <span class="n">gammas</span><span class="p">,</span> <span class="n">rho_max</span><span class="p">,</span> <span class="n">eos_units</span><span class="p">)</span>

<span class="n">pyr</span><span class="o">.</span><span class="n">save_eos_barotr</span><span class="p">(</span><span class="s2">&quot;example_pp.eos.h5&quot;</span><span class="p">,</span> <span class="n">eos</span><span class="p">)</span>
</pre></div>
</div>
<p>The arguments <cite>rho_bounds</cite> and <cite>gammas</cite>, which would be vectors in the C++ interface,
can be passed as numpy arrays in Python. The dimensionful arguments
<cite>rho_poly</cite> and <cite>rho_bounds</cite> have to be specified in the unit system desired
for the EOS, specified by the <cite>uc</cite> argument with respect to SI units.
See also <a class="reference internal" href="eos_barotr_ref.html#_CPPv4N11EOS_Toolkit22make_eos_barotr_pwpolyE6real_tRKNSt6vectorI6real_tEERKNSt6vectorI6real_tEE6real_t5units" title="EOS_Toolkit::make_eos_barotr_pwpoly"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_eos_barotr_pwpoly()</span></code></a>.</p>
<p>For creating an EOS file that represents tabulated data, use the spline-based
EOS as follows</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eos_units</span>   <span class="o">=</span> <span class="n">pyr</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">geom_solar</span><span class="p">()</span>

<span class="n">eos</span> <span class="o">=</span> <span class="n">pyr</span><span class="o">.</span><span class="n">make_eos_barotr_spline</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">press</span><span class="p">,</span> <span class="n">csnd</span><span class="p">,</span>
             <span class="n">temp</span><span class="p">,</span> <span class="n">efrac</span><span class="p">,</span> <span class="n">is_isentropic</span><span class="p">,</span> <span class="n">range_rho</span><span class="p">,</span> <span class="n">n_poly</span><span class="p">,</span>
             <span class="n">eos_units</span><span class="p">,</span> <span class="n">pts_per_mag</span><span class="p">)</span>

<span class="n">pyr</span><span class="o">.</span><span class="n">save_eos_barotr</span><span class="p">(</span><span class="s2">&quot;example_spline.eos.h5&quot;</span><span class="p">,</span> <span class="n">eos</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>rho</cite>, <cite>eps</cite>, <cite>press</cite>, <cite>csnd</cite>, <cite>temp</cite>, and <cite>efrac</cite> are numpy
arrays with the arbitrarily-spaced tabulated sample points. If temperature
and/or electron fraction are not available, pass an empty list instead.
Any dimensionful arguments have to be specified in the unit system desired
for the EOS, specified by the <cite>eos_units</cite> argument with respect to SI units.
See also <a class="reference internal" href="eos_barotr_ref.html#_CPPv4N11EOS_Toolkit22make_eos_barotr_splineERKNSt6vectorI6real_tEERKNSt6vectorI6real_tEERKNSt6vectorI6real_tEERKNSt6vectorI6real_tEERKNSt6vectorI6real_tEERKNSt6vectorI6real_tEERKNSt6vectorI6real_tEEb8intervalI6real_tE6real_t5unitsNSt6size_tE" title="EOS_Toolkit::make_eos_barotr_spline"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_eos_barotr_spline()</span></code></a></p>
</section>
<section id="tov-solver">
<h2>TOV Solver<a class="headerlink" href="#tov-solver" title="Permalink to this heading">¶</a></h2>
<p>The C++ TOV solver functionality is also accessible from Python. The functions
<a class="reference internal" href="tov_solver_ref.html#_CPPv4N11EOS_Toolkit12get_tov_starEK10eos_barotrK6real_tK18star_accuracy_spec" title="EOS_Toolkit::get_tov_star"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">get_tov_star()</span></code></a> and <a class="reference internal" href="tov_solver_ref.html#_CPPv4N11EOS_Toolkit18get_tov_propertiesEK10eos_barotrK6real_tK18star_accuracy_spec" title="EOS_Toolkit::get_tov_properties"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">get_tov_properties()</span></code></a>
allow the creation of a single star with and without profile information, respectively.
The accuracy requirements are passed as an object that can be created using <a class="reference internal" href="tov_solver_ref.html#_CPPv4N11EOS_Toolkit15star_acc_simpleEbb6real_t6real_tNSt6size_tE" title="EOS_Toolkit::star_acc_simple"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">star_acc_simple()</span></code></a> or
<a class="reference internal" href="tov_solver_ref.html#_CPPv4N11EOS_Toolkit17star_acc_detailedEbb6real_t6real_t6real_t6real_tNSt6size_tE" title="EOS_Toolkit::star_acc_detailed"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">star_acc_detailed()</span></code></a>, same as in C++.</p>
<p>A minor difference to C++ is that getter methods
such as <a class="reference internal" href="tov_solver_ref.html#_CPPv4NK11EOS_Toolkit25spherical_star_properties9grav_massEv" title="EOS_Toolkit::spherical_star_properties::grav_mass"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">grav_mass()</span></code></a> are mapped to Python
object attributes, so in Python one should not add brackets ().
Also, since lambda is a reserved word in Python, the tidal deformability
is called <cite>tov.deformability.lambda_tidal</cite> compared to
<cite>tov.deformability().lambda</cite> in C++.</p>
<p>Methods related to stellar profiles, such as
<a class="reference internal" href="tov_solver_ref.html#_CPPv4NK11EOS_Toolkit14spherical_star13press_from_rcE6real_t" title="EOS_Toolkit::spherical_star::press_from_rc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">press_from_rc()</span></code></a>
are vectorized and accept a numpy array as argument for the radius.
Note that computing TOV solutions is not vectorized, so passing a numpy array as central density
will not work. See below for working with TOV sequences.</p>
</section>
<section id="ns-sequences">
<h2>NS Sequences<a class="headerlink" href="#ns-sequences" title="Permalink to this heading">¶</a></h2>
<p>The interface for NS sequences and their (stable) branches is available
in Python. In particular, use the function
<a class="reference internal" href="ns_seqs_ref.html#_CPPv4N11EOS_Toolkit22make_tov_branch_stableE10eos_barotrK18star_accuracy_spec6real_t6real_t6real_t6real_t6real_t" title="EOS_Toolkit::make_tov_branch_stable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_tov_branch_stable()</span></code></a> for computing a stable branch
for TOV solutions, the function <a class="reference internal" href="ns_seqs_ref.html#_CPPv4N11EOS_Toolkit16save_star_branchENSt6stringERK11star_branch" title="EOS_Toolkit::save_star_branch"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">save_star_branch()</span></code></a>
to save it to file, and the function <a class="reference internal" href="ns_seqs_ref.html#_CPPv4N11EOS_Toolkit16load_star_branchENSt6stringERK5units" title="EOS_Toolkit::load_star_branch"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">load_star_branch()</span></code></a>
to load such a file.</p>
<p>The methods of objects <a class="reference internal" href="ns_seqs_ref.html#_CPPv4N11EOS_Toolkit11star_branchE" title="EOS_Toolkit::star_branch"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">star_branch</span></code></a> (representing stable
branches) are vectorized, i.e., they accept <cite>numpy</cite> arrays. If the input is outside
the valid range, the result is NAN. The same holds for <a class="reference internal" href="ns_seqs_ref.html#_CPPv4N11EOS_Toolkit8star_seqE" title="EOS_Toolkit::star_seq"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">star_seq</span></code></a>
objects representing a general NS sequence.</p>
<p>An example Python script plotting TOV sequences can be found under
<cite>examples/pwpoly_TOV.py</cite>.</p>
</section>
<section id="units">
<h2>Units<a class="headerlink" href="#units" title="Permalink to this heading">¶</a></h2>
<p>The Python bindings include the <a class="reference internal" href="little_helpers.html#_CPPv4N11EOS_Toolkit5unitsE" title="EOS_Toolkit::units"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">EOS_Toolkit::units</span></code></a>
objects, which are used throughout the interface to specify unit systems
in a unified consistent way. The unit objects should also be very
useful on their own, for example in quick interactive calculations.
The very popular system defined by <span class="math notranslate nohighlight">\(G=c=M_\odot=1\)</span> is predefined as
<cite>pyr.units.geom_solar()</cite>. Note this is a function; when setting up
geometric units, the default values for <span class="math notranslate nohighlight">\(G\)</span> and/or <span class="math notranslate nohighlight">\(M_\odot\)</span>
can be overridden by parameters msun_si, g_si.
Unit objects provide specific units via data members such as
<cite>u.density</cite> (try Tab-completion for the complete list!).
Note that temperatures in the EOS framework are always in <cite>MeV</cite> and the unit
conversion objects do not define a temperature unit.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">RePrimAnd</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installing.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="c2p_imhd.html">Primitive Recovery</a></li>
<li class="toctree-l1"><a class="reference internal" href="eos_thermal.html">Thermal EOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="eos_barotr.html">Barotropic EOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="tov_solver.html">TOV Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ns_seqs.html">NS Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="little_helpers.html">Little Helpers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python Bindings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#eos-objects">EOS Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-eos-files">Creating EOS Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tov-solver">TOV Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ns-sequences">NS Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="#units">Units</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="little_helpers.html" title="previous chapter">Little Helpers</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2020, Wolfgang Kastaun.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/python_interf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>